<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="NO response">
  
  
    <meta name="description" content="what you will be,the world will be">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    北京信息科技大学第十一届程序设计竞赛 部分题解 |
    
    种花家</title>
  
    <link rel="shortcut icon" href="/images/rabbit.png">
  
  <link rel="stylesheet" href="../../../../css/style.css">
  <link rel="stylesheet" href="../../../../css/technology.css">
  
    <link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.min.css">
  
  <script src="../../../../js/pace.min.js"></script>
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <section class="outer">
  <article id="post-北京信息科技大学第十一届程序设计竞赛-部分题解" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      北京信息科技大学第十一届程序设计竞赛 部分题解
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href class="article-date">
  <time datetime="2019-07-21T12:37:00.000Z" itemprop="datePublished">2019-07-21</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="../../../../categories/题解/">题解</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h3 id="北京信息科技大学第十一届程序设计竞赛"><a href="#北京信息科技大学第十一届程序设计竞赛" class="headerlink" title="北京信息科技大学第十一届程序设计竞赛"></a><center><a href="https://ac.nowcoder.com/acm/contest/940#question" target="_blank" rel="noopener">北京信息科技大学第十一届程序设计竞赛</a></center></h3><p>感觉没有吉首大学那场好玩。<br>老年选手智商尽失，勉勉强强刷刷水题维持生活。  </p>
<h4 id="A-kotori和糖果"><a href="#A-kotori和糖果" class="headerlink" title="A    kotori和糖果"></a>A    kotori和糖果</h4><p>卡了一天，made竟然是个煞笔题，用map取重剪去搜索节点就可以了，但竟然还会爆INT？？？？<br>题意：n堆石头，每堆一个，合并的代价是两堆数量差值。求合并成一堆最小代价。<br>分析：哈夫曼合并树模型，容易推出公式f(n)=f(n/2)+f((n+1)/2)+(n&amp;1)，但对于n=1e18运算节点太多重复太多，所以用map处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF=0x3f3f3f;</span><br><span class="line">const int N=1e3+10;</span><br><span class="line">map&lt;long long ,long long &gt;q;</span><br><span class="line">long long fun(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;=2) return q[n]=0;</span><br><span class="line">    if(q[n]) return q[n];</span><br><span class="line">    return q[n]=fun(n/2)+fun((n+1)/2)+(n&amp;1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    long long n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    q.clear();</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,fun(n));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-kotori和气球"><a href="#B-kotori和气球" class="headerlink" title="B    kotori和气球"></a>B    kotori和气球</h4><p>题意：n中颜色数量不限的气球，选m个摆成一排，相同颜色不能相邻，方案数对109取余。<br>分析：<code>ans=n*(n-1)*(n-1)* *** *(n-1)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MOD=109;</span><br><span class="line">const int N=1e5+10;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        int ans=n;</span><br><span class="line">        for(int i=1;i&lt;m;i++)</span><br><span class="line">            ans=ans*(n-1)%MOD;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-kotori和出道"><a href="#C-kotori和出道" class="headerlink" title="C    kotori和出道"></a>C    kotori和出道</h4><p>题意：n个人始终成一个环，依次报数，偶数出列，求最后剩下的人是谁。<br>分析：经典约瑟夫环问题。但这题打个表规律就出来了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        t=int(input())</span><br><span class="line">        for i in range(t):</span><br><span class="line">            n=int(input())</span><br><span class="line">            x=int(math.log2(n))</span><br><span class="line">            n=n-2**x</span><br><span class="line">            print(2*n+1)</span><br><span class="line">    except:break</span><br></pre></td></tr></table></figure></p>
<h4 id="D-kotori和迷宫"><a href="#D-kotori和迷宫" class="headerlink" title="D    kotori和迷宫"></a>D    kotori和迷宫</h4><p>题意：意思就是从起点开始搜，到了出口’e’就直接出去，求能到达的出口数量和最近出口的距离。<br>分析：在广搜的基础上加一句即可，判断当前点是否为出口’e’，是直接<code>continue</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MOD=109;</span><br><span class="line">const int N=1e5+10;</span><br><span class="line">int n,m,ans1,ans2,vis[55][55];</span><br><span class="line">char s[55][55];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt;q;</span><br><span class="line">void bfs(int x,int y,int step)</span><br><span class="line">&#123;</span><br><span class="line">    ans1=0,ans2=90;</span><br><span class="line">    node tmp;</span><br><span class="line">    tmp.x=x,tmp.y=y,tmp.step=0;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    while(!q.empty()) q.pop();</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[tmp.x][tmp.y]) continue;</span><br><span class="line">        vis[tmp.x][tmp.y]=1;</span><br><span class="line">        if(s[tmp.x][tmp.y]==&apos;e&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            ans1++;</span><br><span class="line">            ans2=min(ans2,tmp.step);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tmp.x-1&gt;0&amp;&amp;s[tmp.x-1][tmp.y]!=&apos;*&apos;&amp;&amp;!vis[tmp.x-1][tmp.y])</span><br><span class="line">        q.push(node&#123;tmp.x-1,tmp.y,tmp.step+1&#125;);</span><br><span class="line">        if(tmp.x+1&lt;=n&amp;&amp;s[tmp.x+1][tmp.y]!=&apos;*&apos;&amp;&amp;!vis[tmp.x+1][tmp.y])</span><br><span class="line">        q.push(node&#123;tmp.x+1,tmp.y,tmp.step+1&#125;);</span><br><span class="line">        if(tmp.y-1&gt;0&amp;&amp;s[tmp.x][tmp.y-1]!=&apos;*&apos;&amp;&amp;!vis[tmp.x][tmp.y-1])</span><br><span class="line">        q.push(node&#123;tmp.x,tmp.y-1,tmp.step+1&#125;);</span><br><span class="line">        if(tmp.y+1&lt;=m&amp;&amp;s[tmp.x][tmp.y+1]!=&apos;*&apos;&amp;&amp;!vis[tmp.x][tmp.y+1])</span><br><span class="line">        q.push(node&#123;tmp.x,tmp.y+1,tmp.step+1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans1==0) puts(&quot;-1&quot;);</span><br><span class="line">    else printf(&quot;%d %d\n&quot;,ans1,ans2);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        int sx,sy;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%s&quot;,s[i]+1);</span><br><span class="line">            for(int j=1; j&lt;=m; j++)</span><br><span class="line">                if(s[i][j]==&apos;k&apos;)</span><br><span class="line">                    sx=i,sy=j;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(sx,sy,0);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-kotori和素因子"><a href="#E-kotori和素因子" class="headerlink" title="E    kotori和素因子"></a>E    kotori和素因子</h4><ul>
<li>题意：n&le;10个数，每个数&le;1000。从每个数中选出一个素因子，要求所选出的所有素因子不同。求这些素因子的和的最小值。  </li>
<li>分析：正解是暴搜即可。1000以内的数每个数由最多5个素因子之积组成，那么暴力的复杂度是5<sup>10</sup>=9765625。  </li>
<li>题解2：费用流模型。源点0到[1-n]这n个数分别建边容量为1，费用为0；n个数每个数分别与它的素因子建边，容量为1，费用为0（或1，这样素因子到汇点的费用为0即可）；素因子到汇点T建边，容量为1，费用为素因子大小。</li>
<li>想想看这样为什么费用流模型可以？费用流模型在最大流的基础上求最小费用，流量自然是我们这n个数每个数都要选一个，我们给每个数i都创建流量为1的通路，那么最终最大流量就是n，不到n输出-1；费用是素因子对答案的贡献，当一个数有多个素因子时就有多个选择，那么费用流模型会自动找寻增广轨寻求费用最小的那条通道。费用流模型能解决更大的数据范围，具体没算。被自己的机智折服。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF=0x3f3f3f;</span><br><span class="line">const int N=1e3+10;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,next,cap,flow,cost;</span><br><span class="line">&#125; e[N*10];</span><br><span class="line">int head[N],tot,tn;</span><br><span class="line">int pre[N],dis[N];</span><br><span class="line">int vis[N];</span><br><span class="line">void init(int num)</span><br><span class="line">&#123;</span><br><span class="line">    tot=0;//边的数量</span><br><span class="line">    tn=num;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add(int u,int v,int cap,int cost)</span><br><span class="line">&#123;</span><br><span class="line">    e[tot].to=v,e[tot].cap=cap,e[tot].cost=cost,e[tot].flow=0;</span><br><span class="line">    e[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">    e[tot].to=u,e[tot].cap=0,e[tot].cost=-cost,e[tot].flow=0;</span><br><span class="line">    e[tot].next=head[v];</span><br><span class="line">    head[v]=tot++;</span><br><span class="line">&#125;</span><br><span class="line">bool spfa(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    for(int i=0; i&lt;=tn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=INF;</span><br><span class="line">        vis[i]=0;</span><br><span class="line">        pre[i]=-1;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s]=0;</span><br><span class="line">    vis[s]=1;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u]=0;</span><br><span class="line">        for(int i=head[u]; i+1; i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            int v=e[i].to;</span><br><span class="line">            if(e[i].cap&gt;e[i].flow&amp;&amp;dis[v]&gt;dis[u]+e[i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].cost;</span><br><span class="line">                pre[v]=i;</span><br><span class="line">                if(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v]=1;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pre[t]==-1)  return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void mincost_maxflow(int s,int t,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int cost=0;</span><br><span class="line">    int flow=0;</span><br><span class="line">    while(spfa(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">        int Min=INF;</span><br><span class="line">        for(int i=pre[t]; i!=-1; i=pre[e[i^1].to])</span><br><span class="line">            if(Min&gt;e[i].cap-e[i].flow)</span><br><span class="line">                Min=e[i].cap-e[i].flow;</span><br><span class="line">        for(int i=pre[t]; i!=-1; i=pre[e[i^1].to])</span><br><span class="line">        &#123;</span><br><span class="line">            e[i].flow+=Min;</span><br><span class="line">            e[i^1].flow-=Min;</span><br><span class="line">            cost+=e[i].cost*Min;</span><br><span class="line">        &#125;</span><br><span class="line">        flow+=Min;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flow&lt;n||flow&gt;=INF) puts(&quot;-1&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;,cost);</span><br><span class="line">&#125;</span><br><span class="line">int prime[1003],Vis[1003];</span><br><span class="line">int a[50];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,cnt=0;</span><br><span class="line">    memset(prime,-1,sizeof(prime));</span><br><span class="line">    prime[0]=prime[1]=0;</span><br><span class="line">    for(int i=2; i&lt;=1000; i++)</span><br><span class="line">        if(prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=i*i; j&lt;=1000; j+=i)</span><br><span class="line">                prime[j]=0;</span><br><span class="line">            prime[cnt++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        memset(Vis,0,sizeof(Vis));</span><br><span class="line">        int Cnt=0;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">            for(int j=0; j&lt;cnt; j++)</span><br><span class="line">                if(a[i]%prime[j]==0&amp;&amp;Vis[prime[j]]==0)</span><br><span class="line">                    Vis[prime[j]]=++Cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        init(1+n+Cnt+2);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add(0,i,1,0);  //源点到i</span><br><span class="line">            for(int j=0; j&lt;cnt; j++)</span><br><span class="line">                if(a[i]%prime[j]==0)</span><br><span class="line">                    add(i,n+Vis[prime[j]],1,prime[j]);  //i到素因子</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0; j&lt;cnt; j++)</span><br><span class="line">            if(Vis[prime[j]])</span><br><span class="line">                add(n+Vis[prime[j]],n+Cnt+2,1,0);  //素因子到汇点</span><br><span class="line">        mincost_maxflow(0,n+Cnt+2,n);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="H-andy和购物"><a href="#H-andy和购物" class="headerlink" title="H    andy和购物"></a>H    andy和购物</h4><p>题意：水题，排序计算内积即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        t=int(input())</span><br><span class="line">        for i in range(t):</span><br><span class="line">            n=int(input())</span><br><span class="line">            a=list(map(int,input().split()))</span><br><span class="line">            b=list(map(float,input().split()))</span><br><span class="line">            a.sort()</span><br><span class="line">            b.sort(reverse=True)</span><br><span class="line">            ans=0</span><br><span class="line">            for j in range(n):</span><br><span class="line">                ans=ans+a[j]*b[j]</span><br><span class="line">            print(&apos;%.3f&apos;%ans)</span><br><span class="line">    except:break</span><br></pre></td></tr></table></figure></p>
<h4 id="I-andy种树"><a href="#I-andy种树" class="headerlink" title="I    andy种树"></a>I    andy种树</h4><p>题意：每次选一个区间加一，然后最后想知道1-n每个坐标的数是多少。<br>分析：会线段树用线段树区间更新单点查询裸题。不会线段树用左家右减法即可，区间左端点加1，区间右端点再往右一个的位置减一，最后累加。烂大街的技巧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MOD=1e9+7;</span><br><span class="line">const int N=1e6+10;</span><br><span class="line">int a[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        memset(a,0,sizeof(a));</span><br><span class="line">        int l,r;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">         scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span><br><span class="line">         a[l]++;</span><br><span class="line">         a[r+1]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]+=a[i-1];</span><br><span class="line">            printf(&quot;%d%c&quot;,a[i],i==n?&apos;\n&apos;:&apos; &apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="J-andy的树被砍了"><a href="#J-andy的树被砍了" class="headerlink" title="J    andy的树被砍了"></a>J    andy的树被砍了</h4><p>题意：煞笔题还想好好伪装。<br>分析：伤害直接累加，然后求某棵树先加上对应前一个的累加伤害值，再在伤害数组中lower_bound()二分查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MOD=1e9+7;</span><br><span class="line">const int N=1e6+10;</span><br><span class="line">long long a[N],b[N];</span><br><span class="line">int n;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        a[0]=b[0]=0;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;b[i]);</span><br><span class="line">            b[i]+=b[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int pos=lower_bound(b+1,b+n+1,a[i]+b[i-1])-b;</span><br><span class="line">            printf(&quot;%d%c&quot;,pos,i==n?&apos;\n&apos;:&apos; &apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sfz-lyq.cn/2019/07/21/北京信息科技大学第十一届程序设计竞赛-部分题解/" data-id="ck46iz6vf00d2nhpvdk8pxga3" class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/牛客网/">牛客网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/题解/">题解</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="../南航第二周总结/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            2019.7.21 每周总结
          
        </div>
      </a>
    
    
      <a href="../../18/吉首大学2019年程序设计竞赛-部分题解/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">吉首大学2019年程序设计竞赛 部分题解</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
    </div>
    <script src="../../../../js/jquery-2.0.3.min.js"></script>
<script src="../../../../js/lazyload.min.js"></script>
<script src="../../../../js/busuanzi-2.3.pure.min.js"></script>


  <script src="../../../../fancybox/jquery.fancybox.min.js"></script>



  <script src="../../../../js/search.js"></script>


<script src="../../../../js/technology.js"></script>

  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>